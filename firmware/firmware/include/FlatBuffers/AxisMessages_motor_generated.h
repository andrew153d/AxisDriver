// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AXISMESSAGESMOTOR_AXISDRIVER_H_
#define FLATBUFFERS_GENERATED_AXISMESSAGESMOTOR_AXISDRIVER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace AxisDriver {

struct HomeDirectionMessage;
struct HomeDirectionMessageBuilder;

struct HomeSpeedMessage;
struct HomeSpeedMessageBuilder;

struct HomeThresholdMessage;
struct HomeThresholdMessageBuilder;

struct HomedStateMessage;
struct HomedStateMessageBuilder;

struct HomeMessage;
struct HomeMessageBuilder;

struct MotorStateMessage;
struct MotorStateMessageBuilder;

struct MotorBrakeMessage;
struct MotorBrakeMessageBuilder;

struct MaxSpeedMessage;
struct MaxSpeedMessageBuilder;

struct AccelerationMessage;
struct AccelerationMessageBuilder;

struct CurrentPositionMessage;
struct CurrentPositionMessageBuilder;

struct TargetPositionMessage;
struct TargetPositionMessageBuilder;

struct RelativeTargetPositionMessage;
struct RelativeTargetPositionMessageBuilder;

struct VelocityMessage;
struct VelocityMessageBuilder;

struct VelocityAndStepsMessage;
struct VelocityAndStepsMessageBuilder;

struct StartPathMessage;
struct StartPathMessageBuilder;

struct HomeDirectionMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HomeDirectionMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int8_t value() const {
    return GetField<int8_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct HomeDirectionMessageBuilder {
  typedef HomeDirectionMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int8_t value) {
    fbb_.AddElement<int8_t>(HomeDirectionMessage::VT_VALUE, value, 0);
  }
  explicit HomeDirectionMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HomeDirectionMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HomeDirectionMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HomeDirectionMessage> CreateHomeDirectionMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t value = 0) {
  HomeDirectionMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HomeSpeedMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HomeSpeedMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct HomeSpeedMessageBuilder {
  typedef HomeSpeedMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(HomeSpeedMessage::VT_VALUE, value, 0);
  }
  explicit HomeSpeedMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HomeSpeedMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HomeSpeedMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HomeSpeedMessage> CreateHomeSpeedMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  HomeSpeedMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HomeThresholdMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HomeThresholdMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct HomeThresholdMessageBuilder {
  typedef HomeThresholdMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(HomeThresholdMessage::VT_VALUE, value, 0);
  }
  explicit HomeThresholdMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HomeThresholdMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HomeThresholdMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HomeThresholdMessage> CreateHomeThresholdMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  HomeThresholdMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HomedStateMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HomedStateMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct HomedStateMessageBuilder {
  typedef HomedStateMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(HomedStateMessage::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit HomedStateMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HomedStateMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HomedStateMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HomedStateMessage> CreateHomedStateMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  HomedStateMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HomeMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HomeMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct HomeMessageBuilder {
  typedef HomeMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(HomeMessage::VT_VALUE, value, 0);
  }
  explicit HomeMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HomeMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HomeMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HomeMessage> CreateHomeMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  HomeMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct MotorStateMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MotorStateMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct MotorStateMessageBuilder {
  typedef MotorStateMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(MotorStateMessage::VT_VALUE, value, 0);
  }
  explicit MotorStateMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MotorStateMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MotorStateMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MotorStateMessage> CreateMotorStateMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  MotorStateMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct MotorBrakeMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MotorBrakeMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct MotorBrakeMessageBuilder {
  typedef MotorBrakeMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(MotorBrakeMessage::VT_VALUE, value, 0);
  }
  explicit MotorBrakeMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MotorBrakeMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MotorBrakeMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MotorBrakeMessage> CreateMotorBrakeMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  MotorBrakeMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct MaxSpeedMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaxSpeedMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct MaxSpeedMessageBuilder {
  typedef MaxSpeedMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(MaxSpeedMessage::VT_VALUE, value, 0);
  }
  explicit MaxSpeedMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MaxSpeedMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MaxSpeedMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MaxSpeedMessage> CreateMaxSpeedMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  MaxSpeedMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct AccelerationMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelerationMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct AccelerationMessageBuilder {
  typedef AccelerationMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(AccelerationMessage::VT_VALUE, value, 0);
  }
  explicit AccelerationMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccelerationMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccelerationMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AccelerationMessage> CreateAccelerationMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  AccelerationMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct CurrentPositionMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CurrentPositionMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct CurrentPositionMessageBuilder {
  typedef CurrentPositionMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(CurrentPositionMessage::VT_VALUE, value, 0.0f);
  }
  explicit CurrentPositionMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CurrentPositionMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CurrentPositionMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CurrentPositionMessage> CreateCurrentPositionMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  CurrentPositionMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TargetPositionMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TargetPositionMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct TargetPositionMessageBuilder {
  typedef TargetPositionMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(TargetPositionMessage::VT_VALUE, value, 0.0f);
  }
  explicit TargetPositionMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TargetPositionMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TargetPositionMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TargetPositionMessage> CreateTargetPositionMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  TargetPositionMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct RelativeTargetPositionMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RelativeTargetPositionMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct RelativeTargetPositionMessageBuilder {
  typedef RelativeTargetPositionMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(RelativeTargetPositionMessage::VT_VALUE, value, 0.0f);
  }
  explicit RelativeTargetPositionMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RelativeTargetPositionMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RelativeTargetPositionMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RelativeTargetPositionMessage> CreateRelativeTargetPositionMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  RelativeTargetPositionMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VelocityMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VelocityMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct VelocityMessageBuilder {
  typedef VelocityMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(VelocityMessage::VT_VALUE, value, 0.0f);
  }
  explicit VelocityMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VelocityMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VelocityMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VelocityMessage> CreateVelocityMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  VelocityMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VelocityAndStepsMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VelocityAndStepsMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VELOCITY = 4,
    VT_STEPS = 6,
    VT_POSITION_MODE = 8
  };
  int32_t velocity() const {
    return GetField<int32_t>(VT_VELOCITY, 0);
  }
  int32_t steps() const {
    return GetField<int32_t>(VT_STEPS, 0);
  }
  uint8_t position_mode() const {
    return GetField<uint8_t>(VT_POSITION_MODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VELOCITY, 4) &&
           VerifyField<int32_t>(verifier, VT_STEPS, 4) &&
           VerifyField<uint8_t>(verifier, VT_POSITION_MODE, 1) &&
           verifier.EndTable();
  }
};

struct VelocityAndStepsMessageBuilder {
  typedef VelocityAndStepsMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_velocity(int32_t velocity) {
    fbb_.AddElement<int32_t>(VelocityAndStepsMessage::VT_VELOCITY, velocity, 0);
  }
  void add_steps(int32_t steps) {
    fbb_.AddElement<int32_t>(VelocityAndStepsMessage::VT_STEPS, steps, 0);
  }
  void add_position_mode(uint8_t position_mode) {
    fbb_.AddElement<uint8_t>(VelocityAndStepsMessage::VT_POSITION_MODE, position_mode, 0);
  }
  explicit VelocityAndStepsMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VelocityAndStepsMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VelocityAndStepsMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VelocityAndStepsMessage> CreateVelocityAndStepsMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t velocity = 0,
    int32_t steps = 0,
    uint8_t position_mode = 0) {
  VelocityAndStepsMessageBuilder builder_(_fbb);
  builder_.add_steps(steps);
  builder_.add_velocity(velocity);
  builder_.add_position_mode(position_mode);
  return builder_.Finish();
}

struct StartPathMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartPathMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct StartPathMessageBuilder {
  typedef StartPathMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(StartPathMessage::VT_VALUE, value, 0);
  }
  explicit StartPathMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartPathMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartPathMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StartPathMessage> CreateStartPathMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  StartPathMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

}  // namespace AxisDriver

#endif  // FLATBUFFERS_GENERATED_AXISMESSAGESMOTOR_AXISDRIVER_H_
