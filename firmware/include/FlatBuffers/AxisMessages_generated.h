// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AXISMESSAGES_AXISDRIVER_H_
#define FLATBUFFERS_GENERATED_AXISMESSAGES_AXISDRIVER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace AxisDriver {

struct VersionMessage;
struct VersionMessageBuilder;

enum LedStates : int8_t {
  LedStates_OFF = 0,
  LedStates_FLASH_ERROR = 1,
  LedStates_ERROR = 2,
  LedStates_BOOTUP = 3,
  LedStates_RAINBOW = 4,
  LedStates_SOLID = 5,
  LedStates_MAX_VALUE = 6,
  LedStates_MIN = LedStates_OFF,
  LedStates_MAX = LedStates_MAX_VALUE
};

inline const LedStates (&EnumValuesLedStates())[7] {
  static const LedStates values[] = {
    LedStates_OFF,
    LedStates_FLASH_ERROR,
    LedStates_ERROR,
    LedStates_BOOTUP,
    LedStates_RAINBOW,
    LedStates_SOLID,
    LedStates_MAX_VALUE
  };
  return values;
}

inline const char * const *EnumNamesLedStates() {
  static const char * const names[8] = {
    "OFF",
    "FLASH_ERROR",
    "ERROR",
    "BOOTUP",
    "RAINBOW",
    "SOLID",
    "MAX_VALUE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLedStates(LedStates e) {
  if (::flatbuffers::IsOutRange(e, LedStates_OFF, LedStates_MAX_VALUE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLedStates()[index];
}

enum MotorStates : int8_t {
  MotorStates_OFF = 0,
  MotorStates_POSITION = 1,
  MotorStates_VELOCITY = 2,
  MotorStates_VELOCITY_STEP = 3,
  MotorStates_IDLE_ON = 4,
  MotorStates_HOME = 5,
  MotorStates_MIN = MotorStates_OFF,
  MotorStates_MAX = MotorStates_HOME
};

inline const MotorStates (&EnumValuesMotorStates())[6] {
  static const MotorStates values[] = {
    MotorStates_OFF,
    MotorStates_POSITION,
    MotorStates_VELOCITY,
    MotorStates_VELOCITY_STEP,
    MotorStates_IDLE_ON,
    MotorStates_HOME
  };
  return values;
}

inline const char * const *EnumNamesMotorStates() {
  static const char * const names[7] = {
    "OFF",
    "POSITION",
    "VELOCITY",
    "VELOCITY_STEP",
    "IDLE_ON",
    "HOME",
    nullptr
  };
  return names;
}

inline const char *EnumNameMotorStates(MotorStates e) {
  if (::flatbuffers::IsOutRange(e, MotorStates_OFF, MotorStates_HOME)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMotorStates()[index];
}

enum MotorBrake : int8_t {
  MotorBrake_NORMAL = 0,
  MotorBrake_FREEWHEELING = 1,
  MotorBrake_STRONG_BRAKING = 2,
  MotorBrake_BRAKING = 3,
  MotorBrake_MIN = MotorBrake_NORMAL,
  MotorBrake_MAX = MotorBrake_BRAKING
};

inline const MotorBrake (&EnumValuesMotorBrake())[4] {
  static const MotorBrake values[] = {
    MotorBrake_NORMAL,
    MotorBrake_FREEWHEELING,
    MotorBrake_STRONG_BRAKING,
    MotorBrake_BRAKING
  };
  return values;
}

inline const char * const *EnumNamesMotorBrake() {
  static const char * const names[5] = {
    "NORMAL",
    "FREEWHEELING",
    "STRONG_BRAKING",
    "BRAKING",
    nullptr
  };
  return names;
}

inline const char *EnumNameMotorBrake(MotorBrake e) {
  if (::flatbuffers::IsOutRange(e, MotorBrake_NORMAL, MotorBrake_BRAKING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMotorBrake()[index];
}

enum HomeDirection : int8_t {
  HomeDirection_CLOCKWISE = 0,
  HomeDirection_COUNTERCLOCKWISE = 1,
  HomeDirection_MIN = HomeDirection_CLOCKWISE,
  HomeDirection_MAX = HomeDirection_COUNTERCLOCKWISE
};

inline const HomeDirection (&EnumValuesHomeDirection())[2] {
  static const HomeDirection values[] = {
    HomeDirection_CLOCKWISE,
    HomeDirection_COUNTERCLOCKWISE
  };
  return values;
}

inline const char * const *EnumNamesHomeDirection() {
  static const char * const names[3] = {
    "CLOCKWISE",
    "COUNTERCLOCKWISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameHomeDirection(HomeDirection e) {
  if (::flatbuffers::IsOutRange(e, HomeDirection_CLOCKWISE, HomeDirection_COUNTERCLOCKWISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHomeDirection()[index];
}

enum PositionMode : int8_t {
  PositionMode_ABSOLUTE = 0,
  PositionMode_RELATIVE = 1,
  PositionMode_MIN = PositionMode_ABSOLUTE,
  PositionMode_MAX = PositionMode_RELATIVE
};

inline const PositionMode (&EnumValuesPositionMode())[2] {
  static const PositionMode values[] = {
    PositionMode_ABSOLUTE,
    PositionMode_RELATIVE
  };
  return values;
}

inline const char * const *EnumNamesPositionMode() {
  static const char * const names[3] = {
    "ABSOLUTE",
    "RELATIVE",
    nullptr
  };
  return names;
}

inline const char *EnumNamePositionMode(PositionMode e) {
  if (::flatbuffers::IsOutRange(e, PositionMode_ABSOLUTE, PositionMode_RELATIVE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPositionMode()[index];
}

struct VersionMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VersionMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct VersionMessageBuilder {
  typedef VersionMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(VersionMessage::VT_VALUE, value);
  }
  explicit VersionMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VersionMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VersionMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VersionMessage> CreateVersionMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  VersionMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VersionMessage> CreateVersionMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return AxisDriver::CreateVersionMessage(
      _fbb,
      value__);
}

}  // namespace AxisDriver

#endif  // FLATBUFFERS_GENERATED_AXISMESSAGES_AXISDRIVER_H_
