// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AXISMESSAGESHA_AXISDRIVER_H_
#define FLATBUFFERS_GENERATED_AXISMESSAGESHA_AXISDRIVER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace AxisDriver {

struct HAEnableMessage;
struct HAEnableMessageBuilder;

struct HAModeMessage;
struct HAModeMessageBuilder;

struct HAIpAddressMessage;
struct HAIpAddressMessageBuilder;

struct HAVelocitySwitchOnSpeedMessage;
struct HAVelocitySwitchOnSpeedMessageBuilder;

struct HAVelocitySwitchOffSpeedMessage;
struct HAVelocitySwitchOffSpeedMessageBuilder;

struct HAPositionSwitchOnPositionMessage;
struct HAPositionSwitchOnPositionMessageBuilder;

struct HAPositionSwitchOffPositionMessage;
struct HAPositionSwitchOffPositionMessageBuilder;

struct HAVelocitySliderMinMessage;
struct HAVelocitySliderMinMessageBuilder;

struct HAVelocitySliderMaxMessage;
struct HAVelocitySliderMaxMessageBuilder;

struct HAPositionSliderMinMessage;
struct HAPositionSliderMinMessageBuilder;

struct HAPositionSliderMaxMessage;
struct HAPositionSliderMaxMessageBuilder;

struct HAMqttUserMessage;
struct HAMqttUserMessageBuilder;

struct HAMqttPasswordMessage;
struct HAMqttPasswordMessageBuilder;

struct HAMqttNameMessage;
struct HAMqttNameMessageBuilder;

struct HAMqttIconMessage;
struct HAMqttIconMessageBuilder;

struct HAEnableMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAEnableMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct HAEnableMessageBuilder {
  typedef HAEnableMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(HAEnableMessage::VT_VALUE, value, 0);
  }
  explicit HAEnableMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAEnableMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAEnableMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAEnableMessage> CreateHAEnableMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  HAEnableMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HAModeMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAModeMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct HAModeMessageBuilder {
  typedef HAModeMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(HAModeMessage::VT_VALUE, value, 0);
  }
  explicit HAModeMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAModeMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAModeMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAModeMessage> CreateHAModeMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  HAModeMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HAIpAddressMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAIpAddressMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HA_IP_ADDRESS = 4
  };
  uint32_t ha_ip_address() const {
    return GetField<uint32_t>(VT_HA_IP_ADDRESS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_HA_IP_ADDRESS, 4) &&
           verifier.EndTable();
  }
};

struct HAIpAddressMessageBuilder {
  typedef HAIpAddressMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ha_ip_address(uint32_t ha_ip_address) {
    fbb_.AddElement<uint32_t>(HAIpAddressMessage::VT_HA_IP_ADDRESS, ha_ip_address, 0);
  }
  explicit HAIpAddressMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAIpAddressMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAIpAddressMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAIpAddressMessage> CreateHAIpAddressMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ha_ip_address = 0) {
  HAIpAddressMessageBuilder builder_(_fbb);
  builder_.add_ha_ip_address(ha_ip_address);
  return builder_.Finish();
}

struct HAVelocitySwitchOnSpeedMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAVelocitySwitchOnSpeedMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct HAVelocitySwitchOnSpeedMessageBuilder {
  typedef HAVelocitySwitchOnSpeedMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(HAVelocitySwitchOnSpeedMessage::VT_VALUE, value, 0.0f);
  }
  explicit HAVelocitySwitchOnSpeedMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAVelocitySwitchOnSpeedMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAVelocitySwitchOnSpeedMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAVelocitySwitchOnSpeedMessage> CreateHAVelocitySwitchOnSpeedMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  HAVelocitySwitchOnSpeedMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HAVelocitySwitchOffSpeedMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAVelocitySwitchOffSpeedMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct HAVelocitySwitchOffSpeedMessageBuilder {
  typedef HAVelocitySwitchOffSpeedMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(HAVelocitySwitchOffSpeedMessage::VT_VALUE, value, 0.0f);
  }
  explicit HAVelocitySwitchOffSpeedMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAVelocitySwitchOffSpeedMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAVelocitySwitchOffSpeedMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAVelocitySwitchOffSpeedMessage> CreateHAVelocitySwitchOffSpeedMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  HAVelocitySwitchOffSpeedMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HAPositionSwitchOnPositionMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAPositionSwitchOnPositionMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct HAPositionSwitchOnPositionMessageBuilder {
  typedef HAPositionSwitchOnPositionMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(HAPositionSwitchOnPositionMessage::VT_VALUE, value, 0.0f);
  }
  explicit HAPositionSwitchOnPositionMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAPositionSwitchOnPositionMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAPositionSwitchOnPositionMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAPositionSwitchOnPositionMessage> CreateHAPositionSwitchOnPositionMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  HAPositionSwitchOnPositionMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HAPositionSwitchOffPositionMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAPositionSwitchOffPositionMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct HAPositionSwitchOffPositionMessageBuilder {
  typedef HAPositionSwitchOffPositionMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(HAPositionSwitchOffPositionMessage::VT_VALUE, value, 0.0f);
  }
  explicit HAPositionSwitchOffPositionMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAPositionSwitchOffPositionMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAPositionSwitchOffPositionMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAPositionSwitchOffPositionMessage> CreateHAPositionSwitchOffPositionMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  HAPositionSwitchOffPositionMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HAVelocitySliderMinMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAVelocitySliderMinMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct HAVelocitySliderMinMessageBuilder {
  typedef HAVelocitySliderMinMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(HAVelocitySliderMinMessage::VT_VALUE, value, 0.0f);
  }
  explicit HAVelocitySliderMinMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAVelocitySliderMinMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAVelocitySliderMinMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAVelocitySliderMinMessage> CreateHAVelocitySliderMinMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  HAVelocitySliderMinMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HAVelocitySliderMaxMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAVelocitySliderMaxMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct HAVelocitySliderMaxMessageBuilder {
  typedef HAVelocitySliderMaxMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(HAVelocitySliderMaxMessage::VT_VALUE, value, 0.0f);
  }
  explicit HAVelocitySliderMaxMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAVelocitySliderMaxMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAVelocitySliderMaxMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAVelocitySliderMaxMessage> CreateHAVelocitySliderMaxMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  HAVelocitySliderMaxMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HAPositionSliderMinMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAPositionSliderMinMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct HAPositionSliderMinMessageBuilder {
  typedef HAPositionSliderMinMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(HAPositionSliderMinMessage::VT_VALUE, value, 0.0f);
  }
  explicit HAPositionSliderMinMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAPositionSliderMinMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAPositionSliderMinMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAPositionSliderMinMessage> CreateHAPositionSliderMinMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  HAPositionSliderMinMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HAPositionSliderMaxMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAPositionSliderMaxMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct HAPositionSliderMaxMessageBuilder {
  typedef HAPositionSliderMaxMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(HAPositionSliderMaxMessage::VT_VALUE, value, 0.0f);
  }
  explicit HAPositionSliderMaxMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAPositionSliderMaxMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAPositionSliderMaxMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAPositionSliderMaxMessage> CreateHAPositionSliderMaxMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  HAPositionSliderMaxMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HAMqttUserMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAMqttUserMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct HAMqttUserMessageBuilder {
  typedef HAMqttUserMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(HAMqttUserMessage::VT_VALUE, value);
  }
  explicit HAMqttUserMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAMqttUserMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAMqttUserMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAMqttUserMessage> CreateHAMqttUserMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  HAMqttUserMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HAMqttUserMessage> CreateHAMqttUserMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return AxisDriver::CreateHAMqttUserMessage(
      _fbb,
      value__);
}

struct HAMqttPasswordMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAMqttPasswordMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct HAMqttPasswordMessageBuilder {
  typedef HAMqttPasswordMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(HAMqttPasswordMessage::VT_VALUE, value);
  }
  explicit HAMqttPasswordMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAMqttPasswordMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAMqttPasswordMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAMqttPasswordMessage> CreateHAMqttPasswordMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  HAMqttPasswordMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HAMqttPasswordMessage> CreateHAMqttPasswordMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return AxisDriver::CreateHAMqttPasswordMessage(
      _fbb,
      value__);
}

struct HAMqttNameMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAMqttNameMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct HAMqttNameMessageBuilder {
  typedef HAMqttNameMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(HAMqttNameMessage::VT_VALUE, value);
  }
  explicit HAMqttNameMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAMqttNameMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAMqttNameMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAMqttNameMessage> CreateHAMqttNameMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  HAMqttNameMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HAMqttNameMessage> CreateHAMqttNameMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return AxisDriver::CreateHAMqttNameMessage(
      _fbb,
      value__);
}

struct HAMqttIconMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HAMqttIconMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct HAMqttIconMessageBuilder {
  typedef HAMqttIconMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(HAMqttIconMessage::VT_VALUE, value);
  }
  explicit HAMqttIconMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HAMqttIconMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HAMqttIconMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HAMqttIconMessage> CreateHAMqttIconMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value = 0) {
  HAMqttIconMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HAMqttIconMessage> CreateHAMqttIconMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return AxisDriver::CreateHAMqttIconMessage(
      _fbb,
      value__);
}

}  // namespace AxisDriver

#endif  // FLATBUFFERS_GENERATED_AXISMESSAGESHA_AXISDRIVER_H_
