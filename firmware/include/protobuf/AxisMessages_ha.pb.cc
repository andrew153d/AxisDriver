// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: AxisMessages_ha.proto
// Protobuf C++ Version: 6.30.2

#include "AxisMessages_ha.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace AxisDriver {

inline constexpr HAVelocitySwitchOnSpeedMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HAVelocitySwitchOnSpeedMessage::HAVelocitySwitchOnSpeedMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAVelocitySwitchOnSpeedMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAVelocitySwitchOnSpeedMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAVelocitySwitchOnSpeedMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAVelocitySwitchOnSpeedMessageDefaultTypeInternal() {}
  union {
    HAVelocitySwitchOnSpeedMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAVelocitySwitchOnSpeedMessageDefaultTypeInternal _HAVelocitySwitchOnSpeedMessage_default_instance_;

inline constexpr HAVelocitySwitchOffSpeedMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HAVelocitySwitchOffSpeedMessage::HAVelocitySwitchOffSpeedMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAVelocitySwitchOffSpeedMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAVelocitySwitchOffSpeedMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAVelocitySwitchOffSpeedMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAVelocitySwitchOffSpeedMessageDefaultTypeInternal() {}
  union {
    HAVelocitySwitchOffSpeedMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAVelocitySwitchOffSpeedMessageDefaultTypeInternal _HAVelocitySwitchOffSpeedMessage_default_instance_;

inline constexpr HAVelocitySliderMinMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HAVelocitySliderMinMessage::HAVelocitySliderMinMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAVelocitySliderMinMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAVelocitySliderMinMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAVelocitySliderMinMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAVelocitySliderMinMessageDefaultTypeInternal() {}
  union {
    HAVelocitySliderMinMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAVelocitySliderMinMessageDefaultTypeInternal _HAVelocitySliderMinMessage_default_instance_;

inline constexpr HAVelocitySliderMaxMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HAVelocitySliderMaxMessage::HAVelocitySliderMaxMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAVelocitySliderMaxMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAVelocitySliderMaxMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAVelocitySliderMaxMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAVelocitySliderMaxMessageDefaultTypeInternal() {}
  union {
    HAVelocitySliderMaxMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAVelocitySliderMaxMessageDefaultTypeInternal _HAVelocitySliderMaxMessage_default_instance_;

inline constexpr HAPositionSwitchOnPositionMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HAPositionSwitchOnPositionMessage::HAPositionSwitchOnPositionMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAPositionSwitchOnPositionMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAPositionSwitchOnPositionMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAPositionSwitchOnPositionMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAPositionSwitchOnPositionMessageDefaultTypeInternal() {}
  union {
    HAPositionSwitchOnPositionMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAPositionSwitchOnPositionMessageDefaultTypeInternal _HAPositionSwitchOnPositionMessage_default_instance_;

inline constexpr HAPositionSwitchOffPositionMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HAPositionSwitchOffPositionMessage::HAPositionSwitchOffPositionMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAPositionSwitchOffPositionMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAPositionSwitchOffPositionMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAPositionSwitchOffPositionMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAPositionSwitchOffPositionMessageDefaultTypeInternal() {}
  union {
    HAPositionSwitchOffPositionMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAPositionSwitchOffPositionMessageDefaultTypeInternal _HAPositionSwitchOffPositionMessage_default_instance_;

inline constexpr HAPositionSliderMinMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HAPositionSliderMinMessage::HAPositionSliderMinMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAPositionSliderMinMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAPositionSliderMinMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAPositionSliderMinMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAPositionSliderMinMessageDefaultTypeInternal() {}
  union {
    HAPositionSliderMinMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAPositionSliderMinMessageDefaultTypeInternal _HAPositionSliderMinMessage_default_instance_;

inline constexpr HAPositionSliderMaxMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HAPositionSliderMaxMessage::HAPositionSliderMaxMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAPositionSliderMaxMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAPositionSliderMaxMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAPositionSliderMaxMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAPositionSliderMaxMessageDefaultTypeInternal() {}
  union {
    HAPositionSliderMaxMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAPositionSliderMaxMessageDefaultTypeInternal _HAPositionSliderMaxMessage_default_instance_;

inline constexpr HAMqttUserMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR HAMqttUserMessage::HAMqttUserMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAMqttUserMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAMqttUserMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAMqttUserMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAMqttUserMessageDefaultTypeInternal() {}
  union {
    HAMqttUserMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAMqttUserMessageDefaultTypeInternal _HAMqttUserMessage_default_instance_;

inline constexpr HAMqttPasswordMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR HAMqttPasswordMessage::HAMqttPasswordMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAMqttPasswordMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAMqttPasswordMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAMqttPasswordMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAMqttPasswordMessageDefaultTypeInternal() {}
  union {
    HAMqttPasswordMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAMqttPasswordMessageDefaultTypeInternal _HAMqttPasswordMessage_default_instance_;

inline constexpr HAMqttNameMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR HAMqttNameMessage::HAMqttNameMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAMqttNameMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAMqttNameMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAMqttNameMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAMqttNameMessageDefaultTypeInternal() {}
  union {
    HAMqttNameMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAMqttNameMessageDefaultTypeInternal _HAMqttNameMessage_default_instance_;

inline constexpr HAMqttIconMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : value_{},
        _value_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HAMqttIconMessage::HAMqttIconMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAMqttIconMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAMqttIconMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAMqttIconMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAMqttIconMessageDefaultTypeInternal() {}
  union {
    HAMqttIconMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAMqttIconMessageDefaultTypeInternal _HAMqttIconMessage_default_instance_;

inline constexpr HAModeMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR HAModeMessage::HAModeMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAModeMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAModeMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAModeMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAModeMessageDefaultTypeInternal() {}
  union {
    HAModeMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAModeMessageDefaultTypeInternal _HAModeMessage_default_instance_;

inline constexpr HAIpAddressMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        ha_ip_address_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR HAIpAddressMessage::HAIpAddressMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAIpAddressMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAIpAddressMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAIpAddressMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAIpAddressMessageDefaultTypeInternal() {}
  union {
    HAIpAddressMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAIpAddressMessageDefaultTypeInternal _HAIpAddressMessage_default_instance_;

inline constexpr HAEnableMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR HAEnableMessage::HAEnableMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HAEnableMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HAEnableMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HAEnableMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HAEnableMessageDefaultTypeInternal() {}
  union {
    HAEnableMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HAEnableMessageDefaultTypeInternal _HAEnableMessage_default_instance_;
}  // namespace AxisDriver
static constexpr const ::_pb::EnumDescriptor *PROTOBUF_NONNULL *PROTOBUF_NULLABLE
    file_level_enum_descriptors_AxisMessages_5fha_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor *PROTOBUF_NONNULL *PROTOBUF_NULLABLE
    file_level_service_descriptors_AxisMessages_5fha_2eproto = nullptr;
const ::uint32_t
    TableStruct_AxisMessages_5fha_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAEnableMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAEnableMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAEnableMessage, _impl_.value_),
        0,
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAModeMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAModeMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAModeMessage, _impl_.value_),
        0,
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAIpAddressMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAIpAddressMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAIpAddressMessage, _impl_.ha_ip_address_),
        0,
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAVelocitySwitchOnSpeedMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAVelocitySwitchOnSpeedMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAVelocitySwitchOnSpeedMessage, _impl_.value_),
        0,
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAVelocitySwitchOffSpeedMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAVelocitySwitchOffSpeedMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAVelocitySwitchOffSpeedMessage, _impl_.value_),
        0,
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAPositionSwitchOnPositionMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAPositionSwitchOnPositionMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAPositionSwitchOnPositionMessage, _impl_.value_),
        0,
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAPositionSwitchOffPositionMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAPositionSwitchOffPositionMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAPositionSwitchOffPositionMessage, _impl_.value_),
        0,
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAVelocitySliderMinMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAVelocitySliderMinMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAVelocitySliderMinMessage, _impl_.value_),
        0,
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAVelocitySliderMaxMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAVelocitySliderMaxMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAVelocitySliderMaxMessage, _impl_.value_),
        0,
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAPositionSliderMinMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAPositionSliderMinMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAPositionSliderMinMessage, _impl_.value_),
        0,
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAPositionSliderMaxMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAPositionSliderMaxMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAPositionSliderMaxMessage, _impl_.value_),
        0,
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAMqttUserMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAMqttUserMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAMqttUserMessage, _impl_.value_),
        0,
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAMqttPasswordMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAMqttPasswordMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAMqttPasswordMessage, _impl_.value_),
        0,
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAMqttNameMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAMqttNameMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAMqttNameMessage, _impl_.value_),
        0,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAMqttIconMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::AxisDriver::HAMqttIconMessage, _impl_.value_),
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, 9, -1, sizeof(::AxisDriver::HAEnableMessage)},
        {10, 19, -1, sizeof(::AxisDriver::HAModeMessage)},
        {20, 29, -1, sizeof(::AxisDriver::HAIpAddressMessage)},
        {30, 39, -1, sizeof(::AxisDriver::HAVelocitySwitchOnSpeedMessage)},
        {40, 49, -1, sizeof(::AxisDriver::HAVelocitySwitchOffSpeedMessage)},
        {50, 59, -1, sizeof(::AxisDriver::HAPositionSwitchOnPositionMessage)},
        {60, 69, -1, sizeof(::AxisDriver::HAPositionSwitchOffPositionMessage)},
        {70, 79, -1, sizeof(::AxisDriver::HAVelocitySliderMinMessage)},
        {80, 89, -1, sizeof(::AxisDriver::HAVelocitySliderMaxMessage)},
        {90, 99, -1, sizeof(::AxisDriver::HAPositionSliderMinMessage)},
        {100, 109, -1, sizeof(::AxisDriver::HAPositionSliderMaxMessage)},
        {110, 119, -1, sizeof(::AxisDriver::HAMqttUserMessage)},
        {120, 129, -1, sizeof(::AxisDriver::HAMqttPasswordMessage)},
        {130, 139, -1, sizeof(::AxisDriver::HAMqttNameMessage)},
        {140, -1, -1, sizeof(::AxisDriver::HAMqttIconMessage)},
};
static const ::_pb::Message* PROTOBUF_NONNULL const file_default_instances[] = {
    &::AxisDriver::_HAEnableMessage_default_instance_._instance,
    &::AxisDriver::_HAModeMessage_default_instance_._instance,
    &::AxisDriver::_HAIpAddressMessage_default_instance_._instance,
    &::AxisDriver::_HAVelocitySwitchOnSpeedMessage_default_instance_._instance,
    &::AxisDriver::_HAVelocitySwitchOffSpeedMessage_default_instance_._instance,
    &::AxisDriver::_HAPositionSwitchOnPositionMessage_default_instance_._instance,
    &::AxisDriver::_HAPositionSwitchOffPositionMessage_default_instance_._instance,
    &::AxisDriver::_HAVelocitySliderMinMessage_default_instance_._instance,
    &::AxisDriver::_HAVelocitySliderMaxMessage_default_instance_._instance,
    &::AxisDriver::_HAPositionSliderMinMessage_default_instance_._instance,
    &::AxisDriver::_HAPositionSliderMaxMessage_default_instance_._instance,
    &::AxisDriver::_HAMqttUserMessage_default_instance_._instance,
    &::AxisDriver::_HAMqttPasswordMessage_default_instance_._instance,
    &::AxisDriver::_HAMqttNameMessage_default_instance_._instance,
    &::AxisDriver::_HAMqttIconMessage_default_instance_._instance,
};
const char descriptor_table_protodef_AxisMessages_5fha_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\025AxisMessages_ha.proto\022\nAxisDriver\" \n\017H"
    "AEnableMessage\022\r\n\005value\030\001 \001(\r\"\036\n\rHAModeM"
    "essage\022\r\n\005value\030\001 \001(\r\"+\n\022HAIpAddressMess"
    "age\022\025\n\rha_ip_address\030\001 \001(\r\"/\n\036HAVelocity"
    "SwitchOnSpeedMessage\022\r\n\005value\030\001 \001(\002\"0\n\037H"
    "AVelocitySwitchOffSpeedMessage\022\r\n\005value\030"
    "\001 \001(\002\"2\n!HAPositionSwitchOnPositionMessa"
    "ge\022\r\n\005value\030\001 \001(\002\"3\n\"HAPositionSwitchOff"
    "PositionMessage\022\r\n\005value\030\001 \001(\002\"+\n\032HAVelo"
    "citySliderMinMessage\022\r\n\005value\030\001 \001(\002\"+\n\032H"
    "AVelocitySliderMaxMessage\022\r\n\005value\030\001 \001(\002"
    "\"+\n\032HAPositionSliderMinMessage\022\r\n\005value\030"
    "\001 \001(\002\"+\n\032HAPositionSliderMaxMessage\022\r\n\005v"
    "alue\030\001 \001(\002\"\"\n\021HAMqttUserMessage\022\r\n\005value"
    "\030\001 \001(\t\"&\n\025HAMqttPasswordMessage\022\r\n\005value"
    "\030\001 \001(\t\"\"\n\021HAMqttNameMessage\022\r\n\005value\030\001 \001"
    "(\t\"\"\n\021HAMqttIconMessage\022\r\n\005value\030\001 \003(\rb\006"
    "proto3"
};
static ::absl::once_flag descriptor_table_AxisMessages_5fha_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_AxisMessages_5fha_2eproto = {
    false,
    false,
    686,
    descriptor_table_protodef_AxisMessages_5fha_2eproto,
    "AxisMessages_ha.proto",
    &descriptor_table_AxisMessages_5fha_2eproto_once,
    nullptr,
    0,
    15,
    schemas,
    file_default_instances,
    TableStruct_AxisMessages_5fha_2eproto::offsets,
    file_level_enum_descriptors_AxisMessages_5fha_2eproto,
    file_level_service_descriptors_AxisMessages_5fha_2eproto,
};
namespace AxisDriver {
// ===================================================================

class HAEnableMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAEnableMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAEnableMessage, _impl_._has_bits_);
};

HAEnableMessage::HAEnableMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAEnableMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAEnableMessage)
}
HAEnableMessage::HAEnableMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HAEnableMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAEnableMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE HAEnableMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void HAEnableMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.value_ = {};
}
HAEnableMessage::~HAEnableMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAEnableMessage)
  SharedDtor(*this);
}
inline void HAEnableMessage::SharedDtor(MessageLite& self) {
  HAEnableMessage& this_ = static_cast<HAEnableMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAEnableMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAEnableMessage(arena);
}
constexpr auto HAEnableMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HAEnableMessage),
                                            alignof(HAEnableMessage));
}
constexpr auto HAEnableMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAEnableMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAEnableMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAEnableMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAEnableMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAEnableMessage>(), &HAEnableMessage::ByteSizeLong,
              &HAEnableMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAEnableMessage, _impl_._cached_size_),
          false,
      },
      &HAEnableMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAEnableMessage_class_data_ =
        HAEnableMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAEnableMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAEnableMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAEnableMessage_class_data_.tc_table);
  return HAEnableMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
HAEnableMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAEnableMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAEnableMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAEnableMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 value = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HAEnableMessage, _impl_.value_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(HAEnableMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 value = 1;
    {PROTOBUF_FIELD_OFFSET(HAEnableMessage, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void HAEnableMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAEnableMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAEnableMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAEnableMessage& this_ = static_cast<const HAEnableMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAEnableMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAEnableMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAEnableMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 value = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (this_._internal_value() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_value(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAEnableMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAEnableMessage::ByteSizeLong(const MessageLite& base) {
  const HAEnableMessage& this_ = static_cast<const HAEnableMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAEnableMessage::ByteSizeLong() const {
  const HAEnableMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAEnableMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // uint32 value = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (this_._internal_value() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_value());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAEnableMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAEnableMessage*>(&to_msg);
  auto& from = static_cast<const HAEnableMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAEnableMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (from._internal_value() != 0) {
      _this->_impl_.value_ = from._impl_.value_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAEnableMessage::CopyFrom(const HAEnableMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAEnableMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAEnableMessage::InternalSwap(HAEnableMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
}

::google::protobuf::Metadata HAEnableMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAModeMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAModeMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAModeMessage, _impl_._has_bits_);
};

HAModeMessage::HAModeMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAModeMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAModeMessage)
}
HAModeMessage::HAModeMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HAModeMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAModeMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE HAModeMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void HAModeMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.value_ = {};
}
HAModeMessage::~HAModeMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAModeMessage)
  SharedDtor(*this);
}
inline void HAModeMessage::SharedDtor(MessageLite& self) {
  HAModeMessage& this_ = static_cast<HAModeMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAModeMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAModeMessage(arena);
}
constexpr auto HAModeMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HAModeMessage),
                                            alignof(HAModeMessage));
}
constexpr auto HAModeMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAModeMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAModeMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAModeMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAModeMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAModeMessage>(), &HAModeMessage::ByteSizeLong,
              &HAModeMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAModeMessage, _impl_._cached_size_),
          false,
      },
      &HAModeMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAModeMessage_class_data_ =
        HAModeMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAModeMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAModeMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAModeMessage_class_data_.tc_table);
  return HAModeMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
HAModeMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAModeMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAModeMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAModeMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 value = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HAModeMessage, _impl_.value_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(HAModeMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 value = 1;
    {PROTOBUF_FIELD_OFFSET(HAModeMessage, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void HAModeMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAModeMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAModeMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAModeMessage& this_ = static_cast<const HAModeMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAModeMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAModeMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAModeMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 value = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (this_._internal_value() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_value(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAModeMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAModeMessage::ByteSizeLong(const MessageLite& base) {
  const HAModeMessage& this_ = static_cast<const HAModeMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAModeMessage::ByteSizeLong() const {
  const HAModeMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAModeMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // uint32 value = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (this_._internal_value() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_value());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAModeMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAModeMessage*>(&to_msg);
  auto& from = static_cast<const HAModeMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAModeMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (from._internal_value() != 0) {
      _this->_impl_.value_ = from._impl_.value_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAModeMessage::CopyFrom(const HAModeMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAModeMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAModeMessage::InternalSwap(HAModeMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
}

::google::protobuf::Metadata HAModeMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAIpAddressMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAIpAddressMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAIpAddressMessage, _impl_._has_bits_);
};

HAIpAddressMessage::HAIpAddressMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAIpAddressMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAIpAddressMessage)
}
HAIpAddressMessage::HAIpAddressMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HAIpAddressMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAIpAddressMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE HAIpAddressMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void HAIpAddressMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.ha_ip_address_ = {};
}
HAIpAddressMessage::~HAIpAddressMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAIpAddressMessage)
  SharedDtor(*this);
}
inline void HAIpAddressMessage::SharedDtor(MessageLite& self) {
  HAIpAddressMessage& this_ = static_cast<HAIpAddressMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAIpAddressMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAIpAddressMessage(arena);
}
constexpr auto HAIpAddressMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HAIpAddressMessage),
                                            alignof(HAIpAddressMessage));
}
constexpr auto HAIpAddressMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAIpAddressMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAIpAddressMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAIpAddressMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAIpAddressMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAIpAddressMessage>(), &HAIpAddressMessage::ByteSizeLong,
              &HAIpAddressMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAIpAddressMessage, _impl_._cached_size_),
          false,
      },
      &HAIpAddressMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAIpAddressMessage_class_data_ =
        HAIpAddressMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAIpAddressMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAIpAddressMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAIpAddressMessage_class_data_.tc_table);
  return HAIpAddressMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
HAIpAddressMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAIpAddressMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAIpAddressMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAIpAddressMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 ha_ip_address = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HAIpAddressMessage, _impl_.ha_ip_address_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(HAIpAddressMessage, _impl_.ha_ip_address_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 ha_ip_address = 1;
    {PROTOBUF_FIELD_OFFSET(HAIpAddressMessage, _impl_.ha_ip_address_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void HAIpAddressMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAIpAddressMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ha_ip_address_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAIpAddressMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAIpAddressMessage& this_ = static_cast<const HAIpAddressMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAIpAddressMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAIpAddressMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAIpAddressMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 ha_ip_address = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (this_._internal_ha_ip_address() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_ha_ip_address(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAIpAddressMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAIpAddressMessage::ByteSizeLong(const MessageLite& base) {
  const HAIpAddressMessage& this_ = static_cast<const HAIpAddressMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAIpAddressMessage::ByteSizeLong() const {
  const HAIpAddressMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAIpAddressMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // uint32 ha_ip_address = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (this_._internal_ha_ip_address() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_ha_ip_address());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAIpAddressMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAIpAddressMessage*>(&to_msg);
  auto& from = static_cast<const HAIpAddressMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAIpAddressMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (from._internal_ha_ip_address() != 0) {
      _this->_impl_.ha_ip_address_ = from._impl_.ha_ip_address_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAIpAddressMessage::CopyFrom(const HAIpAddressMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAIpAddressMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAIpAddressMessage::InternalSwap(HAIpAddressMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.ha_ip_address_, other->_impl_.ha_ip_address_);
}

::google::protobuf::Metadata HAIpAddressMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAVelocitySwitchOnSpeedMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAVelocitySwitchOnSpeedMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAVelocitySwitchOnSpeedMessage, _impl_._has_bits_);
};

HAVelocitySwitchOnSpeedMessage::HAVelocitySwitchOnSpeedMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAVelocitySwitchOnSpeedMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAVelocitySwitchOnSpeedMessage)
}
HAVelocitySwitchOnSpeedMessage::HAVelocitySwitchOnSpeedMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HAVelocitySwitchOnSpeedMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAVelocitySwitchOnSpeedMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE HAVelocitySwitchOnSpeedMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void HAVelocitySwitchOnSpeedMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.value_ = {};
}
HAVelocitySwitchOnSpeedMessage::~HAVelocitySwitchOnSpeedMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAVelocitySwitchOnSpeedMessage)
  SharedDtor(*this);
}
inline void HAVelocitySwitchOnSpeedMessage::SharedDtor(MessageLite& self) {
  HAVelocitySwitchOnSpeedMessage& this_ = static_cast<HAVelocitySwitchOnSpeedMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAVelocitySwitchOnSpeedMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAVelocitySwitchOnSpeedMessage(arena);
}
constexpr auto HAVelocitySwitchOnSpeedMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HAVelocitySwitchOnSpeedMessage),
                                            alignof(HAVelocitySwitchOnSpeedMessage));
}
constexpr auto HAVelocitySwitchOnSpeedMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAVelocitySwitchOnSpeedMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAVelocitySwitchOnSpeedMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAVelocitySwitchOnSpeedMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAVelocitySwitchOnSpeedMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAVelocitySwitchOnSpeedMessage>(), &HAVelocitySwitchOnSpeedMessage::ByteSizeLong,
              &HAVelocitySwitchOnSpeedMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAVelocitySwitchOnSpeedMessage, _impl_._cached_size_),
          false,
      },
      &HAVelocitySwitchOnSpeedMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAVelocitySwitchOnSpeedMessage_class_data_ =
        HAVelocitySwitchOnSpeedMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAVelocitySwitchOnSpeedMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAVelocitySwitchOnSpeedMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAVelocitySwitchOnSpeedMessage_class_data_.tc_table);
  return HAVelocitySwitchOnSpeedMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
HAVelocitySwitchOnSpeedMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAVelocitySwitchOnSpeedMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAVelocitySwitchOnSpeedMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAVelocitySwitchOnSpeedMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // float value = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(HAVelocitySwitchOnSpeedMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float value = 1;
    {PROTOBUF_FIELD_OFFSET(HAVelocitySwitchOnSpeedMessage, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void HAVelocitySwitchOnSpeedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAVelocitySwitchOnSpeedMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAVelocitySwitchOnSpeedMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAVelocitySwitchOnSpeedMessage& this_ = static_cast<const HAVelocitySwitchOnSpeedMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAVelocitySwitchOnSpeedMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAVelocitySwitchOnSpeedMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAVelocitySwitchOnSpeedMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float value = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          1, this_._internal_value(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAVelocitySwitchOnSpeedMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAVelocitySwitchOnSpeedMessage::ByteSizeLong(const MessageLite& base) {
  const HAVelocitySwitchOnSpeedMessage& this_ = static_cast<const HAVelocitySwitchOnSpeedMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAVelocitySwitchOnSpeedMessage::ByteSizeLong() const {
  const HAVelocitySwitchOnSpeedMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAVelocitySwitchOnSpeedMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // float value = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
        total_size += 5;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAVelocitySwitchOnSpeedMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAVelocitySwitchOnSpeedMessage*>(&to_msg);
  auto& from = static_cast<const HAVelocitySwitchOnSpeedMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAVelocitySwitchOnSpeedMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(from._internal_value()) != 0) {
      _this->_impl_.value_ = from._impl_.value_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAVelocitySwitchOnSpeedMessage::CopyFrom(const HAVelocitySwitchOnSpeedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAVelocitySwitchOnSpeedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAVelocitySwitchOnSpeedMessage::InternalSwap(HAVelocitySwitchOnSpeedMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
}

::google::protobuf::Metadata HAVelocitySwitchOnSpeedMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAVelocitySwitchOffSpeedMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAVelocitySwitchOffSpeedMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAVelocitySwitchOffSpeedMessage, _impl_._has_bits_);
};

HAVelocitySwitchOffSpeedMessage::HAVelocitySwitchOffSpeedMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAVelocitySwitchOffSpeedMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAVelocitySwitchOffSpeedMessage)
}
HAVelocitySwitchOffSpeedMessage::HAVelocitySwitchOffSpeedMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HAVelocitySwitchOffSpeedMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAVelocitySwitchOffSpeedMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE HAVelocitySwitchOffSpeedMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void HAVelocitySwitchOffSpeedMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.value_ = {};
}
HAVelocitySwitchOffSpeedMessage::~HAVelocitySwitchOffSpeedMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAVelocitySwitchOffSpeedMessage)
  SharedDtor(*this);
}
inline void HAVelocitySwitchOffSpeedMessage::SharedDtor(MessageLite& self) {
  HAVelocitySwitchOffSpeedMessage& this_ = static_cast<HAVelocitySwitchOffSpeedMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAVelocitySwitchOffSpeedMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAVelocitySwitchOffSpeedMessage(arena);
}
constexpr auto HAVelocitySwitchOffSpeedMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HAVelocitySwitchOffSpeedMessage),
                                            alignof(HAVelocitySwitchOffSpeedMessage));
}
constexpr auto HAVelocitySwitchOffSpeedMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAVelocitySwitchOffSpeedMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAVelocitySwitchOffSpeedMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAVelocitySwitchOffSpeedMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAVelocitySwitchOffSpeedMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAVelocitySwitchOffSpeedMessage>(), &HAVelocitySwitchOffSpeedMessage::ByteSizeLong,
              &HAVelocitySwitchOffSpeedMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAVelocitySwitchOffSpeedMessage, _impl_._cached_size_),
          false,
      },
      &HAVelocitySwitchOffSpeedMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAVelocitySwitchOffSpeedMessage_class_data_ =
        HAVelocitySwitchOffSpeedMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAVelocitySwitchOffSpeedMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAVelocitySwitchOffSpeedMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAVelocitySwitchOffSpeedMessage_class_data_.tc_table);
  return HAVelocitySwitchOffSpeedMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
HAVelocitySwitchOffSpeedMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAVelocitySwitchOffSpeedMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAVelocitySwitchOffSpeedMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAVelocitySwitchOffSpeedMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // float value = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(HAVelocitySwitchOffSpeedMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float value = 1;
    {PROTOBUF_FIELD_OFFSET(HAVelocitySwitchOffSpeedMessage, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void HAVelocitySwitchOffSpeedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAVelocitySwitchOffSpeedMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAVelocitySwitchOffSpeedMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAVelocitySwitchOffSpeedMessage& this_ = static_cast<const HAVelocitySwitchOffSpeedMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAVelocitySwitchOffSpeedMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAVelocitySwitchOffSpeedMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAVelocitySwitchOffSpeedMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float value = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          1, this_._internal_value(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAVelocitySwitchOffSpeedMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAVelocitySwitchOffSpeedMessage::ByteSizeLong(const MessageLite& base) {
  const HAVelocitySwitchOffSpeedMessage& this_ = static_cast<const HAVelocitySwitchOffSpeedMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAVelocitySwitchOffSpeedMessage::ByteSizeLong() const {
  const HAVelocitySwitchOffSpeedMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAVelocitySwitchOffSpeedMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // float value = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
        total_size += 5;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAVelocitySwitchOffSpeedMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAVelocitySwitchOffSpeedMessage*>(&to_msg);
  auto& from = static_cast<const HAVelocitySwitchOffSpeedMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAVelocitySwitchOffSpeedMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(from._internal_value()) != 0) {
      _this->_impl_.value_ = from._impl_.value_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAVelocitySwitchOffSpeedMessage::CopyFrom(const HAVelocitySwitchOffSpeedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAVelocitySwitchOffSpeedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAVelocitySwitchOffSpeedMessage::InternalSwap(HAVelocitySwitchOffSpeedMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
}

::google::protobuf::Metadata HAVelocitySwitchOffSpeedMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAPositionSwitchOnPositionMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAPositionSwitchOnPositionMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAPositionSwitchOnPositionMessage, _impl_._has_bits_);
};

HAPositionSwitchOnPositionMessage::HAPositionSwitchOnPositionMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAPositionSwitchOnPositionMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAPositionSwitchOnPositionMessage)
}
HAPositionSwitchOnPositionMessage::HAPositionSwitchOnPositionMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HAPositionSwitchOnPositionMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAPositionSwitchOnPositionMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE HAPositionSwitchOnPositionMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void HAPositionSwitchOnPositionMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.value_ = {};
}
HAPositionSwitchOnPositionMessage::~HAPositionSwitchOnPositionMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAPositionSwitchOnPositionMessage)
  SharedDtor(*this);
}
inline void HAPositionSwitchOnPositionMessage::SharedDtor(MessageLite& self) {
  HAPositionSwitchOnPositionMessage& this_ = static_cast<HAPositionSwitchOnPositionMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAPositionSwitchOnPositionMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAPositionSwitchOnPositionMessage(arena);
}
constexpr auto HAPositionSwitchOnPositionMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HAPositionSwitchOnPositionMessage),
                                            alignof(HAPositionSwitchOnPositionMessage));
}
constexpr auto HAPositionSwitchOnPositionMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAPositionSwitchOnPositionMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAPositionSwitchOnPositionMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAPositionSwitchOnPositionMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAPositionSwitchOnPositionMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAPositionSwitchOnPositionMessage>(), &HAPositionSwitchOnPositionMessage::ByteSizeLong,
              &HAPositionSwitchOnPositionMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAPositionSwitchOnPositionMessage, _impl_._cached_size_),
          false,
      },
      &HAPositionSwitchOnPositionMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAPositionSwitchOnPositionMessage_class_data_ =
        HAPositionSwitchOnPositionMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAPositionSwitchOnPositionMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAPositionSwitchOnPositionMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAPositionSwitchOnPositionMessage_class_data_.tc_table);
  return HAPositionSwitchOnPositionMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
HAPositionSwitchOnPositionMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAPositionSwitchOnPositionMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAPositionSwitchOnPositionMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAPositionSwitchOnPositionMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // float value = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(HAPositionSwitchOnPositionMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float value = 1;
    {PROTOBUF_FIELD_OFFSET(HAPositionSwitchOnPositionMessage, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void HAPositionSwitchOnPositionMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAPositionSwitchOnPositionMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAPositionSwitchOnPositionMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAPositionSwitchOnPositionMessage& this_ = static_cast<const HAPositionSwitchOnPositionMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAPositionSwitchOnPositionMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAPositionSwitchOnPositionMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAPositionSwitchOnPositionMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float value = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          1, this_._internal_value(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAPositionSwitchOnPositionMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAPositionSwitchOnPositionMessage::ByteSizeLong(const MessageLite& base) {
  const HAPositionSwitchOnPositionMessage& this_ = static_cast<const HAPositionSwitchOnPositionMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAPositionSwitchOnPositionMessage::ByteSizeLong() const {
  const HAPositionSwitchOnPositionMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAPositionSwitchOnPositionMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // float value = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
        total_size += 5;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAPositionSwitchOnPositionMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAPositionSwitchOnPositionMessage*>(&to_msg);
  auto& from = static_cast<const HAPositionSwitchOnPositionMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAPositionSwitchOnPositionMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(from._internal_value()) != 0) {
      _this->_impl_.value_ = from._impl_.value_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAPositionSwitchOnPositionMessage::CopyFrom(const HAPositionSwitchOnPositionMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAPositionSwitchOnPositionMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAPositionSwitchOnPositionMessage::InternalSwap(HAPositionSwitchOnPositionMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
}

::google::protobuf::Metadata HAPositionSwitchOnPositionMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAPositionSwitchOffPositionMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAPositionSwitchOffPositionMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAPositionSwitchOffPositionMessage, _impl_._has_bits_);
};

HAPositionSwitchOffPositionMessage::HAPositionSwitchOffPositionMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAPositionSwitchOffPositionMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAPositionSwitchOffPositionMessage)
}
HAPositionSwitchOffPositionMessage::HAPositionSwitchOffPositionMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HAPositionSwitchOffPositionMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAPositionSwitchOffPositionMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE HAPositionSwitchOffPositionMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void HAPositionSwitchOffPositionMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.value_ = {};
}
HAPositionSwitchOffPositionMessage::~HAPositionSwitchOffPositionMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAPositionSwitchOffPositionMessage)
  SharedDtor(*this);
}
inline void HAPositionSwitchOffPositionMessage::SharedDtor(MessageLite& self) {
  HAPositionSwitchOffPositionMessage& this_ = static_cast<HAPositionSwitchOffPositionMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAPositionSwitchOffPositionMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAPositionSwitchOffPositionMessage(arena);
}
constexpr auto HAPositionSwitchOffPositionMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HAPositionSwitchOffPositionMessage),
                                            alignof(HAPositionSwitchOffPositionMessage));
}
constexpr auto HAPositionSwitchOffPositionMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAPositionSwitchOffPositionMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAPositionSwitchOffPositionMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAPositionSwitchOffPositionMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAPositionSwitchOffPositionMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAPositionSwitchOffPositionMessage>(), &HAPositionSwitchOffPositionMessage::ByteSizeLong,
              &HAPositionSwitchOffPositionMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAPositionSwitchOffPositionMessage, _impl_._cached_size_),
          false,
      },
      &HAPositionSwitchOffPositionMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAPositionSwitchOffPositionMessage_class_data_ =
        HAPositionSwitchOffPositionMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAPositionSwitchOffPositionMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAPositionSwitchOffPositionMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAPositionSwitchOffPositionMessage_class_data_.tc_table);
  return HAPositionSwitchOffPositionMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
HAPositionSwitchOffPositionMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAPositionSwitchOffPositionMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAPositionSwitchOffPositionMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAPositionSwitchOffPositionMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // float value = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(HAPositionSwitchOffPositionMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float value = 1;
    {PROTOBUF_FIELD_OFFSET(HAPositionSwitchOffPositionMessage, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void HAPositionSwitchOffPositionMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAPositionSwitchOffPositionMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAPositionSwitchOffPositionMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAPositionSwitchOffPositionMessage& this_ = static_cast<const HAPositionSwitchOffPositionMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAPositionSwitchOffPositionMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAPositionSwitchOffPositionMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAPositionSwitchOffPositionMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float value = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          1, this_._internal_value(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAPositionSwitchOffPositionMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAPositionSwitchOffPositionMessage::ByteSizeLong(const MessageLite& base) {
  const HAPositionSwitchOffPositionMessage& this_ = static_cast<const HAPositionSwitchOffPositionMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAPositionSwitchOffPositionMessage::ByteSizeLong() const {
  const HAPositionSwitchOffPositionMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAPositionSwitchOffPositionMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // float value = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
        total_size += 5;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAPositionSwitchOffPositionMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAPositionSwitchOffPositionMessage*>(&to_msg);
  auto& from = static_cast<const HAPositionSwitchOffPositionMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAPositionSwitchOffPositionMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(from._internal_value()) != 0) {
      _this->_impl_.value_ = from._impl_.value_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAPositionSwitchOffPositionMessage::CopyFrom(const HAPositionSwitchOffPositionMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAPositionSwitchOffPositionMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAPositionSwitchOffPositionMessage::InternalSwap(HAPositionSwitchOffPositionMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
}

::google::protobuf::Metadata HAPositionSwitchOffPositionMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAVelocitySliderMinMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAVelocitySliderMinMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAVelocitySliderMinMessage, _impl_._has_bits_);
};

HAVelocitySliderMinMessage::HAVelocitySliderMinMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAVelocitySliderMinMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAVelocitySliderMinMessage)
}
HAVelocitySliderMinMessage::HAVelocitySliderMinMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HAVelocitySliderMinMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAVelocitySliderMinMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE HAVelocitySliderMinMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void HAVelocitySliderMinMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.value_ = {};
}
HAVelocitySliderMinMessage::~HAVelocitySliderMinMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAVelocitySliderMinMessage)
  SharedDtor(*this);
}
inline void HAVelocitySliderMinMessage::SharedDtor(MessageLite& self) {
  HAVelocitySliderMinMessage& this_ = static_cast<HAVelocitySliderMinMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAVelocitySliderMinMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAVelocitySliderMinMessage(arena);
}
constexpr auto HAVelocitySliderMinMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HAVelocitySliderMinMessage),
                                            alignof(HAVelocitySliderMinMessage));
}
constexpr auto HAVelocitySliderMinMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAVelocitySliderMinMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAVelocitySliderMinMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAVelocitySliderMinMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAVelocitySliderMinMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAVelocitySliderMinMessage>(), &HAVelocitySliderMinMessage::ByteSizeLong,
              &HAVelocitySliderMinMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAVelocitySliderMinMessage, _impl_._cached_size_),
          false,
      },
      &HAVelocitySliderMinMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAVelocitySliderMinMessage_class_data_ =
        HAVelocitySliderMinMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAVelocitySliderMinMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAVelocitySliderMinMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAVelocitySliderMinMessage_class_data_.tc_table);
  return HAVelocitySliderMinMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
HAVelocitySliderMinMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAVelocitySliderMinMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAVelocitySliderMinMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAVelocitySliderMinMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // float value = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(HAVelocitySliderMinMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float value = 1;
    {PROTOBUF_FIELD_OFFSET(HAVelocitySliderMinMessage, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void HAVelocitySliderMinMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAVelocitySliderMinMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAVelocitySliderMinMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAVelocitySliderMinMessage& this_ = static_cast<const HAVelocitySliderMinMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAVelocitySliderMinMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAVelocitySliderMinMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAVelocitySliderMinMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float value = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          1, this_._internal_value(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAVelocitySliderMinMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAVelocitySliderMinMessage::ByteSizeLong(const MessageLite& base) {
  const HAVelocitySliderMinMessage& this_ = static_cast<const HAVelocitySliderMinMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAVelocitySliderMinMessage::ByteSizeLong() const {
  const HAVelocitySliderMinMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAVelocitySliderMinMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // float value = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
        total_size += 5;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAVelocitySliderMinMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAVelocitySliderMinMessage*>(&to_msg);
  auto& from = static_cast<const HAVelocitySliderMinMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAVelocitySliderMinMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(from._internal_value()) != 0) {
      _this->_impl_.value_ = from._impl_.value_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAVelocitySliderMinMessage::CopyFrom(const HAVelocitySliderMinMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAVelocitySliderMinMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAVelocitySliderMinMessage::InternalSwap(HAVelocitySliderMinMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
}

::google::protobuf::Metadata HAVelocitySliderMinMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAVelocitySliderMaxMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAVelocitySliderMaxMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAVelocitySliderMaxMessage, _impl_._has_bits_);
};

HAVelocitySliderMaxMessage::HAVelocitySliderMaxMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAVelocitySliderMaxMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAVelocitySliderMaxMessage)
}
HAVelocitySliderMaxMessage::HAVelocitySliderMaxMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HAVelocitySliderMaxMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAVelocitySliderMaxMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE HAVelocitySliderMaxMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void HAVelocitySliderMaxMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.value_ = {};
}
HAVelocitySliderMaxMessage::~HAVelocitySliderMaxMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAVelocitySliderMaxMessage)
  SharedDtor(*this);
}
inline void HAVelocitySliderMaxMessage::SharedDtor(MessageLite& self) {
  HAVelocitySliderMaxMessage& this_ = static_cast<HAVelocitySliderMaxMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAVelocitySliderMaxMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAVelocitySliderMaxMessage(arena);
}
constexpr auto HAVelocitySliderMaxMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HAVelocitySliderMaxMessage),
                                            alignof(HAVelocitySliderMaxMessage));
}
constexpr auto HAVelocitySliderMaxMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAVelocitySliderMaxMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAVelocitySliderMaxMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAVelocitySliderMaxMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAVelocitySliderMaxMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAVelocitySliderMaxMessage>(), &HAVelocitySliderMaxMessage::ByteSizeLong,
              &HAVelocitySliderMaxMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAVelocitySliderMaxMessage, _impl_._cached_size_),
          false,
      },
      &HAVelocitySliderMaxMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAVelocitySliderMaxMessage_class_data_ =
        HAVelocitySliderMaxMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAVelocitySliderMaxMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAVelocitySliderMaxMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAVelocitySliderMaxMessage_class_data_.tc_table);
  return HAVelocitySliderMaxMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
HAVelocitySliderMaxMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAVelocitySliderMaxMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAVelocitySliderMaxMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAVelocitySliderMaxMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // float value = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(HAVelocitySliderMaxMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float value = 1;
    {PROTOBUF_FIELD_OFFSET(HAVelocitySliderMaxMessage, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void HAVelocitySliderMaxMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAVelocitySliderMaxMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAVelocitySliderMaxMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAVelocitySliderMaxMessage& this_ = static_cast<const HAVelocitySliderMaxMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAVelocitySliderMaxMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAVelocitySliderMaxMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAVelocitySliderMaxMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float value = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          1, this_._internal_value(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAVelocitySliderMaxMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAVelocitySliderMaxMessage::ByteSizeLong(const MessageLite& base) {
  const HAVelocitySliderMaxMessage& this_ = static_cast<const HAVelocitySliderMaxMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAVelocitySliderMaxMessage::ByteSizeLong() const {
  const HAVelocitySliderMaxMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAVelocitySliderMaxMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // float value = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
        total_size += 5;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAVelocitySliderMaxMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAVelocitySliderMaxMessage*>(&to_msg);
  auto& from = static_cast<const HAVelocitySliderMaxMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAVelocitySliderMaxMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(from._internal_value()) != 0) {
      _this->_impl_.value_ = from._impl_.value_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAVelocitySliderMaxMessage::CopyFrom(const HAVelocitySliderMaxMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAVelocitySliderMaxMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAVelocitySliderMaxMessage::InternalSwap(HAVelocitySliderMaxMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
}

::google::protobuf::Metadata HAVelocitySliderMaxMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAPositionSliderMinMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAPositionSliderMinMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAPositionSliderMinMessage, _impl_._has_bits_);
};

HAPositionSliderMinMessage::HAPositionSliderMinMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAPositionSliderMinMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAPositionSliderMinMessage)
}
HAPositionSliderMinMessage::HAPositionSliderMinMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HAPositionSliderMinMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAPositionSliderMinMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE HAPositionSliderMinMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void HAPositionSliderMinMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.value_ = {};
}
HAPositionSliderMinMessage::~HAPositionSliderMinMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAPositionSliderMinMessage)
  SharedDtor(*this);
}
inline void HAPositionSliderMinMessage::SharedDtor(MessageLite& self) {
  HAPositionSliderMinMessage& this_ = static_cast<HAPositionSliderMinMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAPositionSliderMinMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAPositionSliderMinMessage(arena);
}
constexpr auto HAPositionSliderMinMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HAPositionSliderMinMessage),
                                            alignof(HAPositionSliderMinMessage));
}
constexpr auto HAPositionSliderMinMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAPositionSliderMinMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAPositionSliderMinMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAPositionSliderMinMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAPositionSliderMinMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAPositionSliderMinMessage>(), &HAPositionSliderMinMessage::ByteSizeLong,
              &HAPositionSliderMinMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAPositionSliderMinMessage, _impl_._cached_size_),
          false,
      },
      &HAPositionSliderMinMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAPositionSliderMinMessage_class_data_ =
        HAPositionSliderMinMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAPositionSliderMinMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAPositionSliderMinMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAPositionSliderMinMessage_class_data_.tc_table);
  return HAPositionSliderMinMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
HAPositionSliderMinMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAPositionSliderMinMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAPositionSliderMinMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAPositionSliderMinMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // float value = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(HAPositionSliderMinMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float value = 1;
    {PROTOBUF_FIELD_OFFSET(HAPositionSliderMinMessage, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void HAPositionSliderMinMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAPositionSliderMinMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAPositionSliderMinMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAPositionSliderMinMessage& this_ = static_cast<const HAPositionSliderMinMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAPositionSliderMinMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAPositionSliderMinMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAPositionSliderMinMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float value = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          1, this_._internal_value(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAPositionSliderMinMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAPositionSliderMinMessage::ByteSizeLong(const MessageLite& base) {
  const HAPositionSliderMinMessage& this_ = static_cast<const HAPositionSliderMinMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAPositionSliderMinMessage::ByteSizeLong() const {
  const HAPositionSliderMinMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAPositionSliderMinMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // float value = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
        total_size += 5;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAPositionSliderMinMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAPositionSliderMinMessage*>(&to_msg);
  auto& from = static_cast<const HAPositionSliderMinMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAPositionSliderMinMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(from._internal_value()) != 0) {
      _this->_impl_.value_ = from._impl_.value_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAPositionSliderMinMessage::CopyFrom(const HAPositionSliderMinMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAPositionSliderMinMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAPositionSliderMinMessage::InternalSwap(HAPositionSliderMinMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
}

::google::protobuf::Metadata HAPositionSliderMinMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAPositionSliderMaxMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAPositionSliderMaxMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAPositionSliderMaxMessage, _impl_._has_bits_);
};

HAPositionSliderMaxMessage::HAPositionSliderMaxMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAPositionSliderMaxMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAPositionSliderMaxMessage)
}
HAPositionSliderMaxMessage::HAPositionSliderMaxMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HAPositionSliderMaxMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAPositionSliderMaxMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE HAPositionSliderMaxMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void HAPositionSliderMaxMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.value_ = {};
}
HAPositionSliderMaxMessage::~HAPositionSliderMaxMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAPositionSliderMaxMessage)
  SharedDtor(*this);
}
inline void HAPositionSliderMaxMessage::SharedDtor(MessageLite& self) {
  HAPositionSliderMaxMessage& this_ = static_cast<HAPositionSliderMaxMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAPositionSliderMaxMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAPositionSliderMaxMessage(arena);
}
constexpr auto HAPositionSliderMaxMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HAPositionSliderMaxMessage),
                                            alignof(HAPositionSliderMaxMessage));
}
constexpr auto HAPositionSliderMaxMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAPositionSliderMaxMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAPositionSliderMaxMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAPositionSliderMaxMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAPositionSliderMaxMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAPositionSliderMaxMessage>(), &HAPositionSliderMaxMessage::ByteSizeLong,
              &HAPositionSliderMaxMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAPositionSliderMaxMessage, _impl_._cached_size_),
          false,
      },
      &HAPositionSliderMaxMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAPositionSliderMaxMessage_class_data_ =
        HAPositionSliderMaxMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAPositionSliderMaxMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAPositionSliderMaxMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAPositionSliderMaxMessage_class_data_.tc_table);
  return HAPositionSliderMaxMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
HAPositionSliderMaxMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAPositionSliderMaxMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAPositionSliderMaxMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAPositionSliderMaxMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // float value = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(HAPositionSliderMaxMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float value = 1;
    {PROTOBUF_FIELD_OFFSET(HAPositionSliderMaxMessage, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void HAPositionSliderMaxMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAPositionSliderMaxMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAPositionSliderMaxMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAPositionSliderMaxMessage& this_ = static_cast<const HAPositionSliderMaxMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAPositionSliderMaxMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAPositionSliderMaxMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAPositionSliderMaxMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float value = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          1, this_._internal_value(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAPositionSliderMaxMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAPositionSliderMaxMessage::ByteSizeLong(const MessageLite& base) {
  const HAPositionSliderMaxMessage& this_ = static_cast<const HAPositionSliderMaxMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAPositionSliderMaxMessage::ByteSizeLong() const {
  const HAPositionSliderMaxMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAPositionSliderMaxMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // float value = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (::absl::bit_cast<::uint32_t>(this_._internal_value()) != 0) {
        total_size += 5;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAPositionSliderMaxMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAPositionSliderMaxMessage*>(&to_msg);
  auto& from = static_cast<const HAPositionSliderMaxMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAPositionSliderMaxMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (::absl::bit_cast<::uint32_t>(from._internal_value()) != 0) {
      _this->_impl_.value_ = from._impl_.value_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAPositionSliderMaxMessage::CopyFrom(const HAPositionSliderMaxMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAPositionSliderMaxMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAPositionSliderMaxMessage::InternalSwap(HAPositionSliderMaxMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
}

::google::protobuf::Metadata HAPositionSliderMaxMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAMqttUserMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAMqttUserMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAMqttUserMessage, _impl_._has_bits_);
};

HAMqttUserMessage::HAMqttUserMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAMqttUserMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAMqttUserMessage)
}
PROTOBUF_NDEBUG_INLINE HAMqttUserMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::AxisDriver::HAMqttUserMessage& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        value_(arena, from.value_) {}

HAMqttUserMessage::HAMqttUserMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const HAMqttUserMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAMqttUserMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  HAMqttUserMessage* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:AxisDriver.HAMqttUserMessage)
}
PROTOBUF_NDEBUG_INLINE HAMqttUserMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        value_(arena) {}

inline void HAMqttUserMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
HAMqttUserMessage::~HAMqttUserMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAMqttUserMessage)
  SharedDtor(*this);
}
inline void HAMqttUserMessage::SharedDtor(MessageLite& self) {
  HAMqttUserMessage& this_ = static_cast<HAMqttUserMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.value_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAMqttUserMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAMqttUserMessage(arena);
}
constexpr auto HAMqttUserMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(HAMqttUserMessage),
                                            alignof(HAMqttUserMessage));
}
constexpr auto HAMqttUserMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAMqttUserMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAMqttUserMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAMqttUserMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAMqttUserMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAMqttUserMessage>(), &HAMqttUserMessage::ByteSizeLong,
              &HAMqttUserMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAMqttUserMessage, _impl_._cached_size_),
          false,
      },
      &HAMqttUserMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAMqttUserMessage_class_data_ =
        HAMqttUserMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAMqttUserMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAMqttUserMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAMqttUserMessage_class_data_.tc_table);
  return HAMqttUserMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 42, 2>
HAMqttUserMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAMqttUserMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAMqttUserMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAMqttUserMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(HAMqttUserMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string value = 1;
    {PROTOBUF_FIELD_OFFSET(HAMqttUserMessage, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\34\5\0\0\0\0\0\0"
    "AxisDriver.HAMqttUserMessage"
    "value"
  }},
};
PROTOBUF_NOINLINE void HAMqttUserMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAMqttUserMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.value_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAMqttUserMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAMqttUserMessage& this_ = static_cast<const HAMqttUserMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAMqttUserMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAMqttUserMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAMqttUserMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string value = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_value().empty()) {
      const std::string& _s = this_._internal_value();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "AxisDriver.HAMqttUserMessage.value");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAMqttUserMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAMqttUserMessage::ByteSizeLong(const MessageLite& base) {
  const HAMqttUserMessage& this_ = static_cast<const HAMqttUserMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAMqttUserMessage::ByteSizeLong() const {
  const HAMqttUserMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAMqttUserMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // string value = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_value().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_value());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAMqttUserMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAMqttUserMessage*>(&to_msg);
  auto& from = static_cast<const HAMqttUserMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAMqttUserMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (!from._internal_value().empty()) {
      _this->_internal_set_value(from._internal_value());
    } else {
      if (_this->_impl_.value_.IsDefault()) {
        _this->_internal_set_value("");
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAMqttUserMessage::CopyFrom(const HAMqttUserMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAMqttUserMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAMqttUserMessage::InternalSwap(HAMqttUserMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, &other->_impl_.value_, arena);
}

::google::protobuf::Metadata HAMqttUserMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAMqttPasswordMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAMqttPasswordMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAMqttPasswordMessage, _impl_._has_bits_);
};

HAMqttPasswordMessage::HAMqttPasswordMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAMqttPasswordMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAMqttPasswordMessage)
}
PROTOBUF_NDEBUG_INLINE HAMqttPasswordMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::AxisDriver::HAMqttPasswordMessage& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        value_(arena, from.value_) {}

HAMqttPasswordMessage::HAMqttPasswordMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const HAMqttPasswordMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAMqttPasswordMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  HAMqttPasswordMessage* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:AxisDriver.HAMqttPasswordMessage)
}
PROTOBUF_NDEBUG_INLINE HAMqttPasswordMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        value_(arena) {}

inline void HAMqttPasswordMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
HAMqttPasswordMessage::~HAMqttPasswordMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAMqttPasswordMessage)
  SharedDtor(*this);
}
inline void HAMqttPasswordMessage::SharedDtor(MessageLite& self) {
  HAMqttPasswordMessage& this_ = static_cast<HAMqttPasswordMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.value_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAMqttPasswordMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAMqttPasswordMessage(arena);
}
constexpr auto HAMqttPasswordMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(HAMqttPasswordMessage),
                                            alignof(HAMqttPasswordMessage));
}
constexpr auto HAMqttPasswordMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAMqttPasswordMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAMqttPasswordMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAMqttPasswordMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAMqttPasswordMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAMqttPasswordMessage>(), &HAMqttPasswordMessage::ByteSizeLong,
              &HAMqttPasswordMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAMqttPasswordMessage, _impl_._cached_size_),
          false,
      },
      &HAMqttPasswordMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAMqttPasswordMessage_class_data_ =
        HAMqttPasswordMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAMqttPasswordMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAMqttPasswordMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAMqttPasswordMessage_class_data_.tc_table);
  return HAMqttPasswordMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 46, 2>
HAMqttPasswordMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAMqttPasswordMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAMqttPasswordMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAMqttPasswordMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(HAMqttPasswordMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string value = 1;
    {PROTOBUF_FIELD_OFFSET(HAMqttPasswordMessage, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\40\5\0\0\0\0\0\0"
    "AxisDriver.HAMqttPasswordMessage"
    "value"
  }},
};
PROTOBUF_NOINLINE void HAMqttPasswordMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAMqttPasswordMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.value_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAMqttPasswordMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAMqttPasswordMessage& this_ = static_cast<const HAMqttPasswordMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAMqttPasswordMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAMqttPasswordMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAMqttPasswordMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string value = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_value().empty()) {
      const std::string& _s = this_._internal_value();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "AxisDriver.HAMqttPasswordMessage.value");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAMqttPasswordMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAMqttPasswordMessage::ByteSizeLong(const MessageLite& base) {
  const HAMqttPasswordMessage& this_ = static_cast<const HAMqttPasswordMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAMqttPasswordMessage::ByteSizeLong() const {
  const HAMqttPasswordMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAMqttPasswordMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // string value = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_value().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_value());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAMqttPasswordMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAMqttPasswordMessage*>(&to_msg);
  auto& from = static_cast<const HAMqttPasswordMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAMqttPasswordMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (!from._internal_value().empty()) {
      _this->_internal_set_value(from._internal_value());
    } else {
      if (_this->_impl_.value_.IsDefault()) {
        _this->_internal_set_value("");
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAMqttPasswordMessage::CopyFrom(const HAMqttPasswordMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAMqttPasswordMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAMqttPasswordMessage::InternalSwap(HAMqttPasswordMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, &other->_impl_.value_, arena);
}

::google::protobuf::Metadata HAMqttPasswordMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAMqttNameMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HAMqttNameMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HAMqttNameMessage, _impl_._has_bits_);
};

HAMqttNameMessage::HAMqttNameMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAMqttNameMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAMqttNameMessage)
}
PROTOBUF_NDEBUG_INLINE HAMqttNameMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::AxisDriver::HAMqttNameMessage& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        value_(arena, from.value_) {}

HAMqttNameMessage::HAMqttNameMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const HAMqttNameMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAMqttNameMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  HAMqttNameMessage* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:AxisDriver.HAMqttNameMessage)
}
PROTOBUF_NDEBUG_INLINE HAMqttNameMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        value_(arena) {}

inline void HAMqttNameMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
HAMqttNameMessage::~HAMqttNameMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAMqttNameMessage)
  SharedDtor(*this);
}
inline void HAMqttNameMessage::SharedDtor(MessageLite& self) {
  HAMqttNameMessage& this_ = static_cast<HAMqttNameMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.value_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAMqttNameMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAMqttNameMessage(arena);
}
constexpr auto HAMqttNameMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(HAMqttNameMessage),
                                            alignof(HAMqttNameMessage));
}
constexpr auto HAMqttNameMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAMqttNameMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAMqttNameMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAMqttNameMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAMqttNameMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAMqttNameMessage>(), &HAMqttNameMessage::ByteSizeLong,
              &HAMqttNameMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAMqttNameMessage, _impl_._cached_size_),
          false,
      },
      &HAMqttNameMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAMqttNameMessage_class_data_ =
        HAMqttNameMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAMqttNameMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAMqttNameMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAMqttNameMessage_class_data_.tc_table);
  return HAMqttNameMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 42, 2>
HAMqttNameMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HAMqttNameMessage, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAMqttNameMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAMqttNameMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(HAMqttNameMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string value = 1;
    {PROTOBUF_FIELD_OFFSET(HAMqttNameMessage, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\34\5\0\0\0\0\0\0"
    "AxisDriver.HAMqttNameMessage"
    "value"
  }},
};
PROTOBUF_NOINLINE void HAMqttNameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAMqttNameMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.value_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAMqttNameMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAMqttNameMessage& this_ = static_cast<const HAMqttNameMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAMqttNameMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAMqttNameMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAMqttNameMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string value = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_value().empty()) {
      const std::string& _s = this_._internal_value();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "AxisDriver.HAMqttNameMessage.value");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAMqttNameMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAMqttNameMessage::ByteSizeLong(const MessageLite& base) {
  const HAMqttNameMessage& this_ = static_cast<const HAMqttNameMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAMqttNameMessage::ByteSizeLong() const {
  const HAMqttNameMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAMqttNameMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // string value = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_value().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_value());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAMqttNameMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAMqttNameMessage*>(&to_msg);
  auto& from = static_cast<const HAMqttNameMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAMqttNameMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (!from._internal_value().empty()) {
      _this->_internal_set_value(from._internal_value());
    } else {
      if (_this->_impl_.value_.IsDefault()) {
        _this->_internal_set_value("");
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAMqttNameMessage::CopyFrom(const HAMqttNameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAMqttNameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAMqttNameMessage::InternalSwap(HAMqttNameMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, &other->_impl_.value_, arena);
}

::google::protobuf::Metadata HAMqttNameMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HAMqttIconMessage::_Internal {
 public:
};

HAMqttIconMessage::HAMqttIconMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAMqttIconMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:AxisDriver.HAMqttIconMessage)
}
PROTOBUF_NDEBUG_INLINE HAMqttIconMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::AxisDriver::HAMqttIconMessage& from_msg)
      : value_{visibility, arena, from.value_},
        _value_cached_byte_size_{0},
        _cached_size_{0} {}

HAMqttIconMessage::HAMqttIconMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const HAMqttIconMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HAMqttIconMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  HAMqttIconMessage* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:AxisDriver.HAMqttIconMessage)
}
PROTOBUF_NDEBUG_INLINE HAMqttIconMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : value_{visibility, arena},
        _value_cached_byte_size_{0},
        _cached_size_{0} {}

inline void HAMqttIconMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
HAMqttIconMessage::~HAMqttIconMessage() {
  // @@protoc_insertion_point(destructor:AxisDriver.HAMqttIconMessage)
  SharedDtor(*this);
}
inline void HAMqttIconMessage::SharedDtor(MessageLite& self) {
  HAMqttIconMessage& this_ = static_cast<HAMqttIconMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HAMqttIconMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HAMqttIconMessage(arena);
}
constexpr auto HAMqttIconMessage::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(HAMqttIconMessage, _impl_.value_) +
          decltype(HAMqttIconMessage::_impl_.value_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(HAMqttIconMessage), alignof(HAMqttIconMessage), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&HAMqttIconMessage::PlacementNew_,
                                 sizeof(HAMqttIconMessage),
                                 alignof(HAMqttIconMessage));
  }
}
constexpr auto HAMqttIconMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HAMqttIconMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HAMqttIconMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HAMqttIconMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HAMqttIconMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HAMqttIconMessage>(), &HAMqttIconMessage::ByteSizeLong,
              &HAMqttIconMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HAMqttIconMessage, _impl_._cached_size_),
          false,
      },
      &HAMqttIconMessage::kDescriptorMethods,
      &descriptor_table_AxisMessages_5fha_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HAMqttIconMessage_class_data_ =
        HAMqttIconMessage::InternalGenerateClassData_();

const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL HAMqttIconMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HAMqttIconMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HAMqttIconMessage_class_data_.tc_table);
  return HAMqttIconMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
HAMqttIconMessage::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HAMqttIconMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::AxisDriver::HAMqttIconMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated uint32 value = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(HAMqttIconMessage, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated uint32 value = 1;
    {PROTOBUF_FIELD_OFFSET(HAMqttIconMessage, _impl_.value_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void HAMqttIconMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisDriver.HAMqttIconMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HAMqttIconMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HAMqttIconMessage& this_ = static_cast<const HAMqttIconMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HAMqttIconMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HAMqttIconMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:AxisDriver.HAMqttIconMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated uint32 value = 1;
  {
    int byte_size = this_._impl_._value_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, this_._internal_value(), byte_size, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisDriver.HAMqttIconMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HAMqttIconMessage::ByteSizeLong(const MessageLite& base) {
  const HAMqttIconMessage& this_ = static_cast<const HAMqttIconMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HAMqttIconMessage::ByteSizeLong() const {
  const HAMqttIconMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:AxisDriver.HAMqttIconMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated uint32 value = 1;
    {
      total_size +=
          ::_pbi::WireFormatLite::UInt32SizeWithPackedTagSize(
              this_._internal_value(), 1,
              this_._impl_._value_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HAMqttIconMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HAMqttIconMessage*>(&to_msg);
  auto& from = static_cast<const HAMqttIconMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AxisDriver.HAMqttIconMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_value()->MergeFrom(from._internal_value());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HAMqttIconMessage::CopyFrom(const HAMqttIconMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisDriver.HAMqttIconMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HAMqttIconMessage::InternalSwap(HAMqttIconMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.value_.InternalSwap(&other->_impl_.value_);
}

::google::protobuf::Metadata HAMqttIconMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace AxisDriver
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ [[maybe_unused]] =
        (::_pbi::AddDescriptors(&descriptor_table_AxisMessages_5fha_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
